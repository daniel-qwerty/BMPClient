// Models.swift
//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Foundation

protocol JSONEncodable {
    func encodeToJSON() -> Any
}

public enum ErrorResponse : Error {
    case Error(Int, Data?, Error)
}

open class Response<T> {
    open let statusCode: Int
    open let header: [String: String]
    open let body: T?

    public init(statusCode: Int, header: [String: String], body: T?) {
        self.statusCode = statusCode
        self.header = header
        self.body = body
    }

    public convenience init(response: HTTPURLResponse, body: T?) {
        let rawHeader = response.allHeaderFields
        var header = [String:String]()
        for (key, value) in rawHeader {
            header[key as! String] = value as? String
        }
        self.init(statusCode: response.statusCode, header: header, body: body)
    }
}

private var once = Int()
public class Decoders {
    static fileprivate var decoders = Dictionary<String, ((AnyObject) -> AnyObject)>()

    public static func addDecoder<T>(clazz: T.Type, decoder: @escaping ((AnyObject) -> T)) {
        let key = "\(T.self)"
        decoders[key] = { decoder($0) as AnyObject }
    }

    public static func decode<T>(clazz: T.Type, discriminator: String, source: AnyObject) -> T {
        let key = discriminator;
        if let decoder = decoders[key] {
            return decoder(source) as! T
        } else {
            fatalError("Source \(source) is not convertible to type \(clazz): Maybe swagger file is insufficient")
        }
    }

    public static func decode<T>(clazz: [T].Type, source: AnyObject) -> [T] {
        let array = source as! [AnyObject]
        return array.map { Decoders.decode(clazz: T.self, source: $0) }
    }

    public static func decode<T, Key: Hashable>(clazz: [Key:T].Type, source: AnyObject) -> [Key:T] {
        let sourceDictionary = source as! [Key: AnyObject]
        var dictionary = [Key:T]()
        for (key, value) in sourceDictionary {
            dictionary[key] = Decoders.decode(clazz: T.self, source: value)
        }
        return dictionary
    }

    public static func decode<T>(clazz: T.Type, source: AnyObject) -> T {
        initialize()
        if T.self is Int32.Type && (source is NSNumber || source is String) {
            return source.int32Value as! T;
        }
        if T.self is Int64.Type && (source is NSNumber || source is String) {
            return source.int64Value as! T;
        }
        if T.self is UUID.Type && source is String {
            return UUID(uuidString: source as! String) as! T
        }
        if source is T {
            return source as! T
        }
        if T.self is Data.Type && source is String {
            return Data(base64Encoded: source as! String) as! T
        }

        let key = "\(T.self)"
        if let decoder = decoders[key] {
           return decoder(source) as! T
        } else {
            fatalError("Source \(source) is not convertible to type \(clazz): Maybe swagger file is insufficient")
        }
    }

    public static func decodeOptional<T>(clazz: T.Type, source: AnyObject?) -> T? {
        if source is NSNull {
            return nil
        }
        return source.map { (source: AnyObject) -> T in
            Decoders.decode(clazz: clazz, source: source)
        }
    }

    public static func decodeOptional<T>(clazz: [T].Type, source: AnyObject?) -> [T]? {
        if source is NSNull {
            return nil
        }
        return source.map { (someSource: AnyObject) -> [T] in
            Decoders.decode(clazz: clazz, source: someSource)
        }
    }

    public static func decodeOptional<T, Key: Hashable>(clazz: [Key:T].Type, source: AnyObject?) -> [Key:T]? {
        if source is NSNull {
            return nil
        }
        return source.map { (someSource: AnyObject) -> [Key:T] in
            Decoders.decode(clazz: clazz, source: someSource)
        }
    }

    private static var __once: () = {
        let formatters = [
            "yyyy-MM-dd",
            "yyyy-MM-dd'T'HH:mm:ssZZZZZ",
            "yyyy-MM-dd'T'HH:mm:ss.SSSZZZZZ",
            "yyyy-MM-dd'T'HH:mm:ss'Z'",
            "yyyy-MM-dd'T'HH:mm:ss.SSS"
        ].map { (format: String) -> DateFormatter in
            let formatter = DateFormatter()
            formatter.dateFormat = format
            formatter.locale = Locale(identifier:"en_US_POSIX")
            return formatter
        }
        // Decoder for Date
        Decoders.addDecoder(clazz: Date.self) { (source: AnyObject) -> Date in
           if let sourceString = source as? String {
                for formatter in formatters {
                    if let date = formatter.date(from: sourceString) {
                        return date
                    }
                }
            }
            if let sourceInt = source as? Int {
                // treat as a java date
                return Date(timeIntervalSince1970: Double(sourceInt / 1000) )
            }
            fatalError("formatter failed to parse \(source)")
        }

        // Decoder for ISOFullDate
        Decoders.addDecoder(clazz: ISOFullDate.self) { (source: AnyObject) -> ISOFullDate in
            if let string = source as? String,
               let isoDate = ISOFullDate.from(string: string) {
                return isoDate
            }
            fatalError("formatter failed to parse \(source)")
        } 

        // Decoder for [AuthRequest]
        Decoders.addDecoder(clazz: [AuthRequest].self) { (source: AnyObject) -> [AuthRequest] in
            return Decoders.decode(clazz: [AuthRequest].self, source: source)
        }
        // Decoder for AuthRequest
        Decoders.addDecoder(clazz: AuthRequest.self) { (source: AnyObject) -> AuthRequest in
            let sourceDictionary = source as! [AnyHashable: Any]

            let instance = AuthRequest()
            instance.email = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["email"] as AnyObject?)
            instance.password = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["password"] as AnyObject?)
            return instance
        }


        // Decoder for [AuthToken]
        Decoders.addDecoder(clazz: [AuthToken].self) { (source: AnyObject) -> [AuthToken] in
            return Decoders.decode(clazz: [AuthToken].self, source: source)
        }
        // Decoder for AuthToken
        Decoders.addDecoder(clazz: AuthToken.self) { (source: AnyObject) -> AuthToken in
            let sourceDictionary = source as! [AnyHashable: Any]

            let instance = AuthToken()
            instance.token = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["token"] as AnyObject?)
            return instance
        }


        // Decoder for [CategoryList]
        Decoders.addDecoder(clazz: [CategoryList].self) { (source: AnyObject) -> [CategoryList] in
            return Decoders.decode(clazz: [CategoryList].self, source: source)
        }
        // Decoder for CategoryList
        Decoders.addDecoder(clazz: CategoryList.self) { (source: AnyObject) -> CategoryList in
            let sourceDictionary = source as! [AnyHashable: Any]

            let instance = CategoryList()
            instance.meta = Decoders.decodeOptional(clazz: PostListMeta.self, source: sourceDictionary["meta"] as AnyObject?)
            instance.data = Decoders.decodeOptional(clazz: Array.self, source: sourceDictionary["data"] as AnyObject?)
            return instance
        }


        // Decoder for [CategoryListData]
        Decoders.addDecoder(clazz: [CategoryListData].self) { (source: AnyObject) -> [CategoryListData] in
            return Decoders.decode(clazz: [CategoryListData].self, source: source)
        }
        // Decoder for CategoryListData
        Decoders.addDecoder(clazz: CategoryListData.self) { (source: AnyObject) -> CategoryListData in
            let sourceDictionary = source as! [AnyHashable: Any]

            let instance = CategoryListData()
            instance.id = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?)
            instance.category = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["category"] as AnyObject?)
            instance.parentId = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["parent_id"] as AnyObject?)
            instance.postCount = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["post_count"] as AnyObject?)
            return instance
        }


        // Decoder for [CursorPaginationInfo]
        Decoders.addDecoder(clazz: [CursorPaginationInfo].self) { (source: AnyObject) -> [CursorPaginationInfo] in
            return Decoders.decode(clazz: [CursorPaginationInfo].self, source: source)
        }
        // Decoder for CursorPaginationInfo
        Decoders.addDecoder(clazz: CursorPaginationInfo.self) { (source: AnyObject) -> CursorPaginationInfo in
            let sourceDictionary = source as! [AnyHashable: Any]

            let instance = CursorPaginationInfo()
            instance.total = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total"] as AnyObject?)
            instance.count = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["count"] as AnyObject?)
            instance.current = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["current"] as AnyObject?)
            instance.prev = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["prev"] as AnyObject?)
            instance.next = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["next"] as AnyObject?)
            return instance
        }


        // Decoder for [ErrorDetails]
        Decoders.addDecoder(clazz: [ErrorDetails].self) { (source: AnyObject) -> [ErrorDetails] in
            return Decoders.decode(clazz: [ErrorDetails].self, source: source)
        }
        // Decoder for ErrorDetails
        Decoders.addDecoder(clazz: ErrorDetails.self) { (source: AnyObject) -> ErrorDetails in
            let sourceDictionary = source as! [AnyHashable: Any]

            let instance = ErrorDetails()
            instance.message = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?)
            instance.statusCode = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["status_code"] as AnyObject?)
            instance.errors = Decoders.decodeOptional(clazz: Array.self, source: sourceDictionary["errors"] as AnyObject?)
            instance.debug = Decoders.decodeOptional(clazz: ErrorDetailsDebug.self, source: sourceDictionary["debug"] as AnyObject?)
            return instance
        }


        // Decoder for [ErrorDetailsDebug]
        Decoders.addDecoder(clazz: [ErrorDetailsDebug].self) { (source: AnyObject) -> [ErrorDetailsDebug] in
            return Decoders.decode(clazz: [ErrorDetailsDebug].self, source: source)
        }
        // Decoder for ErrorDetailsDebug
        Decoders.addDecoder(clazz: ErrorDetailsDebug.self) { (source: AnyObject) -> ErrorDetailsDebug in
            let sourceDictionary = source as! [AnyHashable: Any]

            let instance = ErrorDetailsDebug()
            instance.line = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["line"] as AnyObject?)
            instance.file = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["file"] as AnyObject?)
            instance._class = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["class"] as AnyObject?)
            instance.trace = Decoders.decodeOptional(clazz: Array.self, source: sourceDictionary["trace"] as AnyObject?)
            return instance
        }


        // Decoder for [ErrorDetailsErrors]
        Decoders.addDecoder(clazz: [ErrorDetailsErrors].self) { (source: AnyObject) -> [ErrorDetailsErrors] in
            return Decoders.decode(clazz: [ErrorDetailsErrors].self, source: source)
        }
        // Decoder for ErrorDetailsErrors
        Decoders.addDecoder(clazz: ErrorDetailsErrors.self) { (source: AnyObject) -> ErrorDetailsErrors in
            let sourceDictionary = source as! [AnyHashable: Any]

            let instance = ErrorDetailsErrors()
            instance.name = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?)
            instance.messages = Decoders.decodeOptional(clazz: Array.self, source: sourceDictionary["messages"] as AnyObject?)
            return instance
        }


        // Decoder for [InlineResponse201]
        Decoders.addDecoder(clazz: [InlineResponse201].self) { (source: AnyObject) -> [InlineResponse201] in
            return Decoders.decode(clazz: [InlineResponse201].self, source: source)
        }
        // Decoder for InlineResponse201
        Decoders.addDecoder(clazz: InlineResponse201.self) { (source: AnyObject) -> InlineResponse201 in
            let sourceDictionary = source as! [AnyHashable: Any]

            let instance = InlineResponse201()
            instance.data = Decoders.decodeOptional(clazz: InlineResponse201Data.self, source: sourceDictionary["data"] as AnyObject?)
            instance.message = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?)
            return instance
        }


        // Decoder for [InlineResponse201Data]
        Decoders.addDecoder(clazz: [InlineResponse201Data].self) { (source: AnyObject) -> [InlineResponse201Data] in
            return Decoders.decode(clazz: [InlineResponse201Data].self, source: source)
        }
        // Decoder for InlineResponse201Data
        Decoders.addDecoder(clazz: InlineResponse201Data.self) { (source: AnyObject) -> InlineResponse201Data in
            let sourceDictionary = source as! [AnyHashable: Any]

            let instance = InlineResponse201Data()
            instance.totalVote = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalVote"] as AnyObject?)
            return instance
        }


        // Decoder for [LogoutInfo]
        Decoders.addDecoder(clazz: [LogoutInfo].self) { (source: AnyObject) -> [LogoutInfo] in
            return Decoders.decode(clazz: [LogoutInfo].self, source: source)
        }
        // Decoder for LogoutInfo
        Decoders.addDecoder(clazz: LogoutInfo.self) { (source: AnyObject) -> LogoutInfo in
            let sourceDictionary = source as! [AnyHashable: Any]

            let instance = LogoutInfo()
            instance.userId = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["userId"] as AnyObject?)
            return instance
        }


        // Decoder for [PaginationInfo]
        Decoders.addDecoder(clazz: [PaginationInfo].self) { (source: AnyObject) -> [PaginationInfo] in
            return Decoders.decode(clazz: [PaginationInfo].self, source: source)
        }
        // Decoder for PaginationInfo
        Decoders.addDecoder(clazz: PaginationInfo.self) { (source: AnyObject) -> PaginationInfo in
            let sourceDictionary = source as! [AnyHashable: Any]

            let instance = PaginationInfo()
            instance.total = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total"] as AnyObject?)
            instance.count = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["count"] as AnyObject?)
            instance.perPage = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["per_page"] as AnyObject?)
            instance.currentPage = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["current_page"] as AnyObject?)
            instance.totalPages = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?)
            return instance
        }


        // Decoder for [PostList]
        Decoders.addDecoder(clazz: [PostList].self) { (source: AnyObject) -> [PostList] in
            return Decoders.decode(clazz: [PostList].self, source: source)
        }
        // Decoder for PostList
        Decoders.addDecoder(clazz: PostList.self) { (source: AnyObject) -> PostList in
            let sourceDictionary = source as! [AnyHashable: Any]

            let instance = PostList()
            instance.meta = Decoders.decodeOptional(clazz: PostListMeta.self, source: sourceDictionary["meta"] as AnyObject?)
            instance.data = Decoders.decodeOptional(clazz: Array.self, source: sourceDictionary["data"] as AnyObject?)
            return instance
        }


        // Decoder for [PostListData]
        Decoders.addDecoder(clazz: [PostListData].self) { (source: AnyObject) -> [PostListData] in
            return Decoders.decode(clazz: [PostListData].self, source: source)
        }
        // Decoder for PostListData
        Decoders.addDecoder(clazz: PostListData.self) { (source: AnyObject) -> PostListData in
            let sourceDictionary = source as! [AnyHashable: Any]

            let instance = PostListData()
            instance.id = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?)
            instance.description = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?)
            instance.categoryId = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["category_id"] as AnyObject?)
            instance.createdAt = Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["created_at"] as AnyObject?)
            instance.photos = Decoders.decodeOptional(clazz: Array.self, source: sourceDictionary["photos"] as AnyObject?)
            instance.user = Decoders.decodeOptional(clazz: User.self, source: sourceDictionary["user"] as AnyObject?)
            instance.votes = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["votes"] as AnyObject?)
            instance.voted = Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voted"] as AnyObject?)
            instance.expired = Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["expired"] as AnyObject?)
            return instance
        }


        // Decoder for [PostListMeta]
        Decoders.addDecoder(clazz: [PostListMeta].self) { (source: AnyObject) -> [PostListMeta] in
            return Decoders.decode(clazz: [PostListMeta].self, source: source)
        }
        // Decoder for PostListMeta
        Decoders.addDecoder(clazz: PostListMeta.self) { (source: AnyObject) -> PostListMeta in
            let sourceDictionary = source as! [AnyHashable: Any]

            let instance = PostListMeta()
            instance.pagination = Decoders.decodeOptional(clazz: PaginationInfo.self, source: sourceDictionary["pagination"] as AnyObject?)
            return instance
        }


        // Decoder for [PostListPhotos]
        Decoders.addDecoder(clazz: [PostListPhotos].self) { (source: AnyObject) -> [PostListPhotos] in
            return Decoders.decode(clazz: [PostListPhotos].self, source: source)
        }
        // Decoder for PostListPhotos
        Decoders.addDecoder(clazz: PostListPhotos.self) { (source: AnyObject) -> PostListPhotos in
            let sourceDictionary = source as! [AnyHashable: Any]

            let instance = PostListPhotos()
            instance.id = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?)
            instance.postId = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["post_id"] as AnyObject?)
            instance.file = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["file"] as AnyObject?)
            instance.fileOriginal = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["file_original"] as AnyObject?)
            instance.fileUrl = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["file_url"] as AnyObject?)
            instance.fileSize = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["file_size"] as AnyObject?)
            instance.fileThumbnail = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["file_thumbnail"] as AnyObject?)
            instance.fileThumbnailUrl = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["file_thumbnail_url"] as AnyObject?)
            instance.fileThumbnailSize = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["file_thumbnail_size"] as AnyObject?)
            return instance
        }


        // Decoder for [QuestionStoreData]
        Decoders.addDecoder(clazz: [QuestionStoreData].self) { (source: AnyObject) -> [QuestionStoreData] in
            return Decoders.decode(clazz: [QuestionStoreData].self, source: source)
        }
        // Decoder for QuestionStoreData
        Decoders.addDecoder(clazz: QuestionStoreData.self) { (source: AnyObject) -> QuestionStoreData in
            let sourceDictionary = source as! [AnyHashable: Any]

            let instance = QuestionStoreData()
            instance.question = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["question"] as AnyObject?)
            return instance
        }


        // Decoder for [RefreshToken]
        Decoders.addDecoder(clazz: [RefreshToken].self) { (source: AnyObject) -> [RefreshToken] in
            return Decoders.decode(clazz: [RefreshToken].self, source: source)
        }
        // Decoder for RefreshToken
        Decoders.addDecoder(clazz: RefreshToken.self) { (source: AnyObject) -> RefreshToken in
            let sourceDictionary = source as! [AnyHashable: Any]

            let instance = RefreshToken()
            instance.token = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["token"] as AnyObject?)
            return instance
        }


        // Decoder for [ResetPasswordRequest]
        Decoders.addDecoder(clazz: [ResetPasswordRequest].self) { (source: AnyObject) -> [ResetPasswordRequest] in
            return Decoders.decode(clazz: [ResetPasswordRequest].self, source: source)
        }
        // Decoder for ResetPasswordRequest
        Decoders.addDecoder(clazz: ResetPasswordRequest.self) { (source: AnyObject) -> ResetPasswordRequest in
            let sourceDictionary = source as! [AnyHashable: Any]

            let instance = ResetPasswordRequest()
            instance.email = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["email"] as AnyObject?)
            return instance
        }


        // Decoder for [SuccessConfirmation]
        Decoders.addDecoder(clazz: [SuccessConfirmation].self) { (source: AnyObject) -> [SuccessConfirmation] in
            return Decoders.decode(clazz: [SuccessConfirmation].self, source: source)
        }
        // Decoder for SuccessConfirmation
        Decoders.addDecoder(clazz: SuccessConfirmation.self) { (source: AnyObject) -> SuccessConfirmation in
            let sourceDictionary = source as! [AnyHashable: Any]

            let instance = SuccessConfirmation()
            instance.message = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?)
            return instance
        }


        // Decoder for [UpdateUserPasswordBody]
        Decoders.addDecoder(clazz: [UpdateUserPasswordBody].self) { (source: AnyObject) -> [UpdateUserPasswordBody] in
            return Decoders.decode(clazz: [UpdateUserPasswordBody].self, source: source)
        }
        // Decoder for UpdateUserPasswordBody
        Decoders.addDecoder(clazz: UpdateUserPasswordBody.self) { (source: AnyObject) -> UpdateUserPasswordBody in
            let sourceDictionary = source as! [AnyHashable: Any]

            let instance = UpdateUserPasswordBody()
            instance.password = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["password"] as AnyObject?)
            instance.newPassword = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["new_password"] as AnyObject?)
            return instance
        }


        // Decoder for [UpdateUserProfileData]
        Decoders.addDecoder(clazz: [UpdateUserProfileData].self) { (source: AnyObject) -> [UpdateUserProfileData] in
            return Decoders.decode(clazz: [UpdateUserProfileData].self, source: source)
        }
        // Decoder for UpdateUserProfileData
        Decoders.addDecoder(clazz: UpdateUserProfileData.self) { (source: AnyObject) -> UpdateUserProfileData in
            let sourceDictionary = source as! [AnyHashable: Any]

            let instance = UpdateUserProfileData()
            instance.email = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["email"] as AnyObject?)
            instance.firstName = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["first_name"] as AnyObject?)
            instance.lastName = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["last_name"] as AnyObject?)
            instance.gender = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["gender"] as AnyObject?)
            instance.city = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["city"] as AnyObject?)
            instance.state = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["state"] as AnyObject?)
            instance.zipCode = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["zip_code"] as AnyObject?)
            return instance
        }


        // Decoder for [User]
        Decoders.addDecoder(clazz: [User].self) { (source: AnyObject) -> [User] in
            return Decoders.decode(clazz: [User].self, source: source)
        }
        // Decoder for User
        Decoders.addDecoder(clazz: User.self) { (source: AnyObject) -> User in
            let sourceDictionary = source as! [AnyHashable: Any]

            let instance = User()
            instance.id = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?)
            instance.firstName = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["first_name"] as AnyObject?)
            instance.lastName = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["last_name"] as AnyObject?)
            instance.email = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["email"] as AnyObject?)
            instance.isAdmin = Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["is_admin"] as AnyObject?)
            instance.gender = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["gender"] as AnyObject?)
            instance.city = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["city"] as AnyObject?)
            instance.state = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["state"] as AnyObject?)
            instance.zipCode = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["zip_code"] as AnyObject?)
            instance.avatarFileUrl = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["avatar_file_url"] as AnyObject?)
            instance.createdAt = Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["created_at"] as AnyObject?)
            instance.voteCount = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["vote_count"] as AnyObject?)
            instance.voteLimit = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["vote_limit"] as AnyObject?)
            instance.freePostLimitPerMonth = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["free_post_limit_per_month"] as AnyObject?)
            instance.freePostCount = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["free_post_count"] as AnyObject?)
            return instance
        }


        // Decoder for [UserStoreData]
        Decoders.addDecoder(clazz: [UserStoreData].self) { (source: AnyObject) -> [UserStoreData] in
            return Decoders.decode(clazz: [UserStoreData].self, source: source)
        }
        // Decoder for UserStoreData
        Decoders.addDecoder(clazz: UserStoreData.self) { (source: AnyObject) -> UserStoreData in
            let sourceDictionary = source as! [AnyHashable: Any]

            let instance = UserStoreData()
            instance.email = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["email"] as AnyObject?)
            instance.password = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["password"] as AnyObject?)
            instance.firstName = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["first_name"] as AnyObject?)
            instance.lastName = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["last_name"] as AnyObject?)
            instance.gender = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["gender"] as AnyObject?)
            instance.city = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["city"] as AnyObject?)
            instance.state = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["state"] as AnyObject?)
            instance.zipCode = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["zip_code"] as AnyObject?)
            return instance
        }
    }()

    static fileprivate func initialize() {
        _ = Decoders.__once
    }
}
